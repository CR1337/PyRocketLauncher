#!/bin/python3

import json
import os
import shutil
import subprocess
import sys
import time
from datetime import datetime
from difflib import SequenceMatcher
from typing import Any, Callable, Dict, List

import requests


class Paths:

    SELF: str = os.path.realpath(__file__)

    PARENT: str = "/" + os.path.join(*(SELF.split(os.path.sep)[:-3]))
    HOME: str = "/" + os.path.join(*(SELF.split(os.path.sep)[:-2]))
    CONFIG_PATH: str = os.path.join(HOME, "config")
    BIN: str = os.path.join(HOME, "bin")
    LOGS: str = os.path.join(HOME, "logs")
    HELP: str = os.path.join(HOME, "doc/rl_help")

    RL_RUN: str = os.path.join(HOME, "rl_run.py")

    HELP_RL: str = os.path.join(HELP, "rl.txt")
    HELP_RL_CONFIG: str = os.path.join(HELP, "rl_config.txt")
    HELP_RL_STATUS: str = os.path.join(HELP, "rl_status.txt")
    HELP_RL_CRONJOB: str = os.path.join(HELP, "rl_cronjob.txt")
    HELP_RL_LOGS: str = os.path.join(HELP, "rl_logs.txt")

    RL_INSTALL: str = os.path.join(BIN, "rl-install")

    CONFIG: str = os.path.join(CONFIG_PATH, "config.json")
    RUN_CONFIG: str = os.path.join(CONFIG_PATH, "run_config.json")

    MODEL: str = "/sys/firmware/devicetree/base/model"
    I2C: str = "/dev/i2c-1"
    SUDOERS_RL: str = "/etc/sudoers.d/rl"
    CRONJOB: str = "/etc/cron.d/rl"


class Ids:

    IMAGE: str = "rl_image"
    DEVICE_CONTAINER: str = 'rl_device_container'
    MASTER_CONTAINER: str = 'rl_master_container'


class TerminalColors:

    DEFAULT: str = "\033[39m"
    BLACK: str = "\033[30m"
    DARK_RED: str = "\033[31m"
    DARK_GREEN: str = "\033[32m"
    DARK_YELLOW: str = "(Orange-ish"
    DARK_BLUE: str = "\033[34m"
    DARK_MAGENTA: str = "\033[35m"
    DARK_CYAN: str = "\033[36m"
    LIGHT_GRAY: str = "\033[37m"
    DARK_GRAY: str = "\033[90m"
    RED: str = "\033[91m"
    GREEN: str = "\033[92m"
    ORANGE: str = "\033[93m"
    BLUE: str = "\033[94m"
    MAGENTA: str = "\033[95m"
    CYAN: str = "\033[96m"
    WHITE: str = "\033[97m"
    RESET: str = '\033[0m'


class Output:

    @staticmethod
    def info(message: str):
        print(f"{TerminalColors.CYAN}INFO> {message}{TerminalColors.RESET}")

    @staticmethod
    def important(message: str):
        print(
            f"{TerminalColors.MAGENTA}IMPORTANT> "
            f"{message}{TerminalColors.RESET}"
        )

    @staticmethod
    def error(message: str):
        print(
            f"{TerminalColors.RED}ERROR> {message}{TerminalColors.RESET}",
            file=sys.stderr
        )

    @classmethod
    def critical(cls, message: str):
        cls.error(message)
        exit(1)

    @staticmethod
    def success(message: str):
        print(
            f"{TerminalColors.GREEN}SUCCESS> {message}{TerminalColors.RESET}"
        )
        exit(0)

    @classmethod
    def wrong_usage(cls):
        cls.error("Wrong arguments! Run 'sudo rl help' for help.")

    @staticmethod
    def print_file(filename: str):
        with open(filename, 'r', encoding='utf-8') as file:
            print(file.read())
        exit(0)

    @classmethod
    def unexpected_error(cls):
        cls.critical("Unexpected error!")


class Command:

    _command: str

    def __init__(self, command: str):
        self._command = command

    def run(self, show_output: bool = True):
        subprocess.run(
            self._command,
            shell=True,
            stdout=(None if show_output else subprocess.DEVNULL),
            stderr=(None if show_output else subprocess.DEVNULL)
        )

    def run_background(self):
        subprocess.Popen(
            self._command,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            start_new_session=True,
            cwd=Paths.HOME
        )

    def get_output(self) -> str:
        return subprocess.check_output(
            self._command,
            shell=True,
            stderr=subprocess.DEVNULL
        ).decode(encoding='ascii')

    def get_returncode(self, show_output: bool = True) -> int:
        process = subprocess.Popen(
            self._command,
            shell=True,
            stdout=(None if show_output else subprocess.DEVNULL),
            stderr=(None if show_output else subprocess.DEVNULL)
        )
        process.wait()
        return process.returncode


class FormatValidator:

    @staticmethod
    def get_all_timezones():
        command = Command("timedatectl list-timezones")
        timezones = [
            tz.strip()
            for tz in command.get_output().split("\n")
        ]
        return timezones

    @classmethod
    def validate_timezone(cls, value: str) -> bool:
        return value in cls.get_all_timezones()

    @staticmethod
    def validate_datetime(value: str) -> bool:
        try:
            datetime.strptime(value, '%Y-%m-%d %H:%M:%S')
        except ValueError:
            return False
        else:
            return True

    @staticmethod
    def validate_bool(value: str) -> bool:
        return value in ['0', '1']

    @staticmethod
    def validate_int(value: str, max_value: int, min_value: int) -> bool:
        try:
            value = int(value)
        except ValueError:
            return False
        else:
            if value > max_value:
                return False
            if value < min_value:
                return False
            return True


class Ask:

    @staticmethod
    def string(prompt: str) -> str:
        try:
            return input(prompt)
        except KeyboardInterrupt:
            print()
            return None

    @classmethod
    def boolean(cls, prompt: str) -> bool:
        while True:
            answer = cls.string(prompt).lower()
            if answer is None:
                return None
            if len(answer) == 1 and answer in "yn":
                return answer == 'y'

    @classmethod
    def integer(
        cls, prompt: str, min_value: int = None, max_value: int = None
    ) -> int:
        while True:
            answer = cls.string(prompt)
            if answer is None:
                return None
            try:
                number = int(answer)
            except ValueError:
                pass
            else:
                if min_value is not None:
                    if number < min_value:
                        continue
                if max_value is not None:
                    if number > max_value:
                        continue
                return number

    @classmethod
    def timezone(cls, prompt: str) -> str:
        timezones = FormatValidator.get_all_timezones()
        lower_timezones = [
            tz.lower()
            for tz in timezones
        ]
        while True:
            answer = cls.string(prompt)
            if answer is None:
                return None
            if answer.lower() in lower_timezones:
                index = lower_timezones.index(answer.lower())
                return timezones[index]

            def sort_key(item: str) -> float:
                return SequenceMatcher(None, answer, item).ratio()

            sorted_timezones = sorted(timezones, key=sort_key, reverse=True)

            print()
            print("Did you mean...?")
            print("Type a number.")
            for idx, timezone in enumerate(sorted_timezones[:10]):
                print(f"[{idx}] {timezone}")

            selection = Ask.integer("> ", 0, 9)
            if selection is None:
                return None

            return sorted_timezones[selection]

    @classmethod
    def datetime(cls, prompt: str) -> str:
        while True:
            answer = cls.string(prompt)
            if answer is None:
                return None
            if FormatValidator.validate_datetime(answer):
                return answer


class Network:

    @staticmethod
    def get_gateway_ip() -> str:
        command = Command("/sbin/ip route|awk '/default/ { print $3 }'")
        return command.get_output().strip()


class Cronjob:

    @classmethod
    def register(cls):
        Output.info("Registering cronjob...")
        if cls.is_registered():
            Output.critical("A cronjob was already registered!")
        with open(Paths.CRONJOB, 'w', encoding='ascii') as file:
            file.write(f"@reboot root {Paths.SELF} run\n")
        os.chmod(Paths.CRONJOB, int('600', 8))

    @classmethod
    def deregister(cls):
        Output.info("Deregistering cronjob...")
        if not cls.is_registered():
            Output.critical("There is no cronjob registered!")
        os.remove(Paths.CRONJOB)

    @staticmethod
    def is_registered() -> bool:
        return os.path.exists(Paths.CRONJOB)


class Config:

    @staticmethod
    def _get(key: str, filename: str) -> Any:
        with open(filename, 'r', encoding='utf-8') as file:
            return json.load(file)[key]

    @staticmethod
    def _set(key: str, value: Any, filename: str):
        with open(filename, 'r', encoding='utf-8') as file:
            data = json.load(file)
        data[key] = value
        with open(filename, 'w', encoding='utf-8') as file:
            json.dump(data, file)

    @classmethod
    def _get_config(cls, key: str) -> Any:
        return cls._get(key, Paths.CONFIG)

    @classmethod
    def _set_config(cls, key: str, value: Any):
        cls._set(key, value, Paths.CONFIG)

    @classmethod
    def _get_run_config(cls, key: str) -> Any:
        return cls._get(key, Paths.RUN_CONFIG)

    @classmethod
    def _set_run_config(cls, key: str, value: Any):
        cls._set(key, value, Paths.RUN_CONFIG)

    @classmethod
    def get_device_id(cls) -> str:
        return cls._get_config('device_id')

    @classmethod
    def set_device_id(cls, value: str):
        cls._set_config('device_id', str(value))

    @classmethod
    def get_chip_amount(cls) -> int:
        return cls._get_config('chip_amount')

    @classmethod
    def set_chip_amount(cls, value: int):
        cls._set_config('chip_amount', int(value))

    @classmethod
    def get_debug(cls) -> bool:
        return cls._get_config('debug')

    @classmethod
    def set_debug(cls, value: bool):
        cls._set_config('debug', bool(value))

    @classmethod
    def get_master(cls) -> bool:
        return cls._get_run_config('master')

    @classmethod
    def set_master(cls, value: bool):
        cls._set_run_config('master', bool(value))

    @classmethod
    def get_device(cls) -> bool:
        return cls._get_run_config('device')

    @classmethod
    def set_device(cls, value: bool):
        cls._set_run_config('device', bool(value))

    @classmethod
    def get_timezone(cls) -> str:
        command = Command("cat /etc/timezone")
        return command.get_output().strip()

    @classmethod
    def set_timezone(cls, value: str):
        command = Command(f"timedatectl set-timezone {value}")
        if command.get_returncode() != 0:
            Output.critical("Error setting timezone!")

    @classmethod
    def get_system_time(cls) -> str:
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    @classmethod
    def set_system_time(cls, value: str) -> str:
        time_string = str(value).strip()
        command = Command(f"timedatectl set-time '{time_string}'")
        if command.get_returncode() != 0:
            Output.critical(
                f"Invalid time format: {time_string}\n"
                "Format has to be 'YYYY-MM-DD HH:MM:SS'"
            )
        Output.info(f"Set time to {time_string}.")

    @classmethod
    def validate_value(cls, key: str, value: Any) -> bool:
        if cls.TYPES[key] == str:
            if key == 'timezone':
                return FormatValidator.validate_timezone(value)
            elif key == 'system_time':
                return FormatValidator.validate_datetime(value)
            else:
                return True
        elif key == 'chip_amount':
            FormatValidator.validate_int(value, 1, 26)
        elif cls.TYPES[key] == bool:
            return FormatValidator.validate_bool(value)

    ASK_METHODS: Dict[str, Callable] = {
        'device_id': Ask.string,
        'chip_amount': Ask.integer,
        'debug': Ask.boolean,
        'master': Ask.boolean,
        'device': Ask.boolean,
        'timezone': Ask.timezone,
        'system_time': Ask.datetime
    }

    TYPES: Dict[str, type] = {
        'device_id': str,
        'chip_amount': int,
        'debug': bool,
        'master': bool,
        'device': bool,
        'timezone': str,
        'system_time': str
    }


Config.SET_METHODS: Dict[str, Callable] = {
    'device_id': Config.set_device_id,
    'chip_amount': Config.set_chip_amount,
    'debug': Config.set_debug,
    'master': Config.set_master,
    'device': Config.set_device,
    'timezone': Config.set_timezone,
    'system_time': Config.set_system_time
}


Config.GET_METHODS: Dict[str, Callable] = {
    'device_id': Config.get_device_id,
    'chip_amount': Config.get_chip_amount,
    'debug': Config.get_debug,
    'master': Config.get_master,
    'device': Config.get_device,
    'timezone': Config.get_timezone,
    'system_time': Config.get_system_time
}


class ConfigWizard:

    KEY_COUNT: int = len(Config.ASK_METHODS.keys())

    @classmethod
    def _print_main_menu(cls):
        print()
        print("This is the current configuration.")
        print("Type a number to change an entry.")
        print()
        for idx, key in enumerate(Config.ASK_METHODS.keys()):
            print(f"[{idx}] {key}: {Config.GET_METHODS[key]()}")
        print()
        print(f"[{cls.KEY_COUNT}] DONE")

    @classmethod
    def _mainloop(cls):
        while True:
            cls._print_main_menu()
            selection = Ask.integer("> ", 0, cls.KEY_COUNT)
            if selection is None:
                break
            if selection == cls.KEY_COUNT:
                break
            key = list(Config.ASK_METHODS.keys())[selection]

            ask_for_bool = (Config.ASK_METHODS[key] == Ask.boolean)
            ask_for_chip_amount = (key == 'chip_amount')
            value = Config.ASK_METHODS[key](
                f"Enter the new value for {key} "
                f"{'(yn)' if ask_for_bool else ''}"
                f"{'(1-26)' if ask_for_chip_amount else ''}"
                "> ",
                *([1, 26] if ask_for_chip_amount else [])
            )
            if value is None:
                break

            Config.SET_METHODS[key](value)

    @classmethod
    def run(cls):
        Output.info("Starting PyRocketLauncher Config Wizard...")
        cls._mainloop()


class Logs:

    SEP: str = ":::"

    LEVEL_COLORS: Dict[str, str] = {
        'DEBUG': TerminalColors.LIGHT_GRAY,
        'INFO': TerminalColors.CYAN,
        'WARNING': TerminalColors.DARK_YELLOW,
        'ERROR': TerminalColors.DARK_RED,
        'CRITICAL': TerminalColors.RED
    }

    @staticmethod
    def get_log_filenames() -> List[str]:
        filenames = [
            os.path.join(os.path.abspath(Paths.LOGS), fn)
            for fn in os.listdir(Paths.LOGS)
        ]
        log_filenames = [fn for fn in filenames if fn.endswith(".log")]
        if len(log_filenames) == 0:
            Output.critical("There are no logfiles.")
        return log_filenames

    @classmethod
    def get_latest_log_filename(cls, mode: str) -> str:
        log_filenames = [
            fn for fn in sorted(cls.get_log_filenames())
            if mode in fn.split(os.path.sep)[-1]
        ]
        return log_filenames[-1]

    @classmethod
    def clear_logs(cls):
        if not Ask.boolean(
            "Are you sure you want to delete all logfiles? (yn)> "
        ):
            Output.success("Logfile deletion was cancelled.")
        Output.info("Deleting all logfiles...")
        for filename in cls.get_log_filenames():
            os.remove(os.path.join(Paths.LOGS, filename))

    @classmethod
    def print_latest_raw(cls):
        latest_log_filename = cls.get_latest_log_filename()
        with open(
            os.path.join(Paths.LOGS, latest_log_filename), 'r',
            encoding='utf-8'
        ) as file:
            print(file.read())

    @classmethod
    def print_latest_pretty(cls):
        latest_log_filename = cls.get_latest_log_filename()
        with open(
            os.path.join(Paths.LOGS, latest_log_filename), 'r',
            encoding='utf-8'
        ) as file:
            lines = file.readlines()
        for line in lines:
            level = line.split(cls.SEP)[1]
            color_code = cls.LEVEL_COLORS.get(
                level, TerminalColors.DEFAULT
            )
            print(f"{color_code}{line}{TerminalColors.RESET}")


class Status:

    @staticmethod
    def _check_localhost(port: int) -> bool:
        try:
            response = requests.get(f"http://localhost:{port}/", timeout=3)
            response.raise_for_status()
        except Exception:
            return False
        else:
            return True

    @classmethod
    def is_running(cls) -> bool:
        command = Command("pgrep -af python")
        running_py_scripts = command.get_output()
        if Paths.RL_RUN not in running_py_scripts:
            return False
        if Config.get_master():
            if not cls._check_localhost(80):
                return False
        if Config.get_device():
            if not cls._check_localhost(5000):
                return False
        return True

    @staticmethod
    def is_cronjob_registered() -> bool:
        return Cronjob.is_registered()

    @staticmethod
    def is_on_pi() -> bool:
        if not os.path.exists(Paths.MODEL):
            return False
        try:
            with open(
                Paths.MODEL,
                'r', encoding='ascii'
            ) as file:
                return "pi" in file.read().lower()
        except FileNotFoundError:
            return False

    @staticmethod
    def get_gateway_ip() -> str:
        return Network.get_gateway_ip()


Status.GET_METHODS: Dict[str, Callable] = {
    'running': Status.is_running,
    'cronjob': Status.is_cronjob_registered,
    'pi': Status.is_on_pi,
    'gateway_ip': Status.get_gateway_ip
}


class RlManager:

    @classmethod
    def setup(cls):
        if Status.is_running():
            cls.stop()
        ConfigWizard.run()
        if not Status.is_cronjob_registered():
            Cronjob.register()
        cls.run()
        Output.info("This system should now be fully functional.")
        Output.info("For further options run: 'sudo rl help'")

    @staticmethod
    def run():
        if Status.is_running():
            Output.critical("System is already running!")
        if Config.get_device():
            Output.info("Starting device...")
            command = Command(
                [sys.executable, Paths.RL_RUN]
            )
            command.run_background()
        if Config.get_master():
            Output.info("Starting master...")
            command = Command(
                [sys.executable, Paths.RL_RUN, '--master']
            )
            command.run_background()
        Output.info("Waiting for server running...")
        while not Status.is_running():
            time.sleep(1)

    @staticmethod
    def stop():
        if not Status.is_running():
            Output.critical("System is not running!")
        Output.info("Stopping system...")
        command = Command(f"pkill -9 -f {Paths.RL_RUN}")
        if command.get_returncode() != -9:
            Output.error("Error stopping device!")

    @classmethod
    def restart(cls):
        Output.info("Restarting system...")
        cls.stop()
        cls.run()

    @classmethod
    def update(cls):
        Output.info("Updating System...")
        was_running = False
        if Status.is_running():
            was_running = True
            cls.stop()
        command = Command(f"git -C {Paths.HOME} pull")
        if command.get_returncode() != 0:
            Output.unexpected_error()
        if was_running:
            cls.run()

    @classmethod
    def uninstall(cls):
        Output.info("Starting deinstallation process...")
        Output.important("Are you sure you want to uninstall?")
        if not Ask.boolean("Are you sure you want to uninstall? (yn)> "):
            Output.success("Deinstallation process was cancelled.")
        keyword = 'uninstall'
        answer = Ask.string(f"Type '{keyword}' if you are really sure> ")
        if answer != keyword:
            Output.success("Deinstallation process was cancelled.")
        if Status.is_running():
            cls.stop()
        if Cronjob.is_registered():
            Cronjob.deregister()
        Output.info("Removing bin directory from SECURE_PATH...")
        os.remove(Paths.SUDOERS_RL)
        Output.info("Copying install script to parent directory...")
        shutil.copy(Paths.RL_INSTALL, Paths.PARENT)
        Output.info("Removing all files...")
        shutil.rmtree(Paths.HOME)


class UserInterface:

    @classmethod
    def _check_for_no_further_arguments(
        cls, args: List[str], subcommand_name: str
    ):
        if len(args) != 1:
            Output.critical(
                f"'rl {subcommand_name}{' ' if subcommand_name else ''}"
                f"{args[0]}' takes no further arguments!\nRun 'sudo rl"
                f"{' ' if subcommand_name else ''}{subcommand_name} help'."
            )

    @classmethod
    def _check_for_further_arguments(
        cls, args: List[str], count: int, subcommand_name: str
    ):
        if len(args) != count + 1:
            Output.critical(
                f"'rl {subcommand_name}{' ' if subcommand_name else ''}"
                f"{args[0]}' takes {count} further "
                f"argument{'s' if count > 1 else ''}!\nRun 'sudo rl"
                f"{' ' if subcommand_name else ''}{subcommand_name} help'."
            )

    @staticmethod
    def _require_root():
        if os.geteuid() != 0:
            Output.critical("Please run as root!")

    @classmethod
    def run(cls, args: List[str]):
        cls._require_root()

        if len(args) < 1:
            Output.critical(
                "Invalid number of arguments!\nRun 'sudo rl help'."
            )

        if args[0] in [
            'setup', 'run', 'stop', 'restart',
            'update', 'uninstall', 'help'
        ]:
            cls._check_for_no_further_arguments(args, "")
            if args[0] == 'setup':
                RlManager.setup()
                Output.success("Setup done.")
            elif args[0] == 'run':
                RlManager.run()
                Output.success("System is now running.")
            elif args[0] == 'stop':
                RlManager.stop()
                Output.success("System was stopped.")
            elif args[0] == 'restart':
                RlManager.restart()
                Output.success("System was restarted.")
            elif args[0] == 'update':
                RlManager.update()
                Output.success("Update done.")
            elif args[0] == 'uninstall':
                RlManager.uninstall()
                Output.success("Deinstallation done.")
            elif args[0] == 'help':
                Output.print_file(Paths.HELP_RL)

        elif args[0] == 'config':
            cls._config(args[1:])
        elif args[0] == 'status':
            cls._status(args[1:])
        elif args[0] == 'cronjob':
            cls._cronjob(args[1:])
        elif args[0] == 'logs':
            cls._logs(args[1:])
        else:
            Output.critical("Unknown command!\nRun 'sudo rl help'.")

    @classmethod
    def _config(cls, args: List[str]):
        if len(args) < 1:
            Output.critical(
                "Invalid number of arguments!\nRun 'sudo rl config help'."
            )

        if args[0] in ['list', 'wizard', 'help']:
            cls._check_for_no_further_arguments(args, "config")
            if args[0] == 'list':
                max_key_len = max([len(k) for k in Config.GET_METHODS.keys()])
                for key in Config.GET_METHODS.keys():
                    printed_key = f"{key}:{' ' * (max_key_len - len(key))}"
                    print(f"{printed_key}\t{Config.GET_METHODS[key]()}")
            elif args[0] == 'wizard':
                ConfigWizard.run(show_rebuild_info=True)
                Output.success("Exited wizard.")
            elif args[0] == 'help':
                Output.print_file(Paths.HELP_RL_CONFIG)

        elif args[0] == 'set':
            cls._check_for_further_arguments(args, 2, "config")
            key, value = args[1], args[2]
            if key not in Config.SET_METHODS.keys():
                Output.critical(
                    f"Invalid key: {key}!\nRun 'sudo rl config help'."
                )
            if not Config.validate_value(key, value):
                Output.critical(
                    f"Invalid value: {value}\nRun 'sudo rl config help'."
                )
            Config.SET_METHODS[key](value)
            Output.success(f"Set {key} to {value}.")

        elif args[0] == 'get':
            cls._check_for_further_arguments(args, 1, "config")
            key = args[1]
            if key not in Config.SET_METHODS.keys():
                Output.critical(
                    f"Invalid key: {key}!\nRun 'sudo rl config help'."
                )
            print(f"{key}:\t{Config.GET_METHODS[key]()}")

        else:
            Output.critical("Unknown command!\nRun 'sudo rl config help'.")

    @classmethod
    def _status(cls, args: List[str]):
        if len(args) < 1:
            Output.critical(
                "Invalid number of arguments!\nRun 'sudo rl status help'."
            )

        if args[0] in ['list', 'help']:
            if args[0] == 'list':
                max_key_len = max([len(k) for k in Status.GET_METHODS.keys()])
                for key in Status.GET_METHODS.keys():
                    printed_key = f"{key}:{' ' * (max_key_len - len(key))}"
                    print(f"{printed_key}\t{Status.GET_METHODS[key]()}")
            elif args[0] == 'help':
                Output.print_file(Paths.HELP_RL_STATUS)

        elif args[0] == 'get':
            cls._check_for_further_arguments(args, 1, "status")
            key = args[1]
            if key not in Status.GET_METHODS.keys():
                Output.critical(
                    f"Invalid key: {key}!\nRun 'sudo rl status help'."
                )
            print(f"{key}:\t{Status.GET_METHODS[key]()}")

        else:
            Output.critical("Unknown command!\nRun 'sudo rl status help'.")

    @classmethod
    def _cronjob(cls, args: List[str]):
        if len(args) < 1:
            Output.critical(
                "Invalid number of arguments!\nRun 'sudo rl cronjob help'."
            )

        if args[0] in ['register', 'deregister', 'status', 'help']:
            if args[0] == 'register':
                Cronjob.register()
                Output.success("Cronjob registered.")
            elif args[0] == 'deregister':
                Cronjob.deregister()
                Output.success("Cronjob deregistered.")
            elif args[0] == 'status':
                print(f"cronjob:\t{Cronjob.is_registered()}")
            elif args[0] == 'help':
                Output.print_file(Paths.HELP_RL_CRONJOB)

        else:
            Output.critical("Unknown command!\nRun 'sudo rl cronjob help'.")

    @classmethod
    def _logs(cls, args: List[str]):
        if len(args) < 1:
            Output.critical(
                "Invalid number of arguments!\nRun 'sudo rl logs help'."
            )

        if args[0] in ['list', 'latest', 'clear', 'help']:
            if args[0] == 'list':
                for filename in Logs.get_log_filenames():
                    print(filename)
            elif args[0] == 'latest':
                cls._check_for_further_arguments(args, 1, "logs")
                mode = args[1]
                if mode not in ['master', 'device']:
                    Output.critical(f"Unexpected argument: {mode}")
                print(Logs.get_latest_log_filename(mode))
            elif args[0] == 'clear':
                Logs.clear_logs()
                Output.success("All logfiles were deleted.")
            elif args[0] == 'help':
                Output.print_file(Paths.HELP_RL_LOGS)

        else:
            Output.critical("Unknown command!\nRun 'sudo rl logs help'.")


if __name__ == "__main__":
    UserInterface.run(sys.argv[1:])
